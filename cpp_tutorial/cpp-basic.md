# CPP 기본 정보

> 코드로 표현이 불가능한 것은 여기에 정리

### STL

c++ 기본 제공 라이브러리임
자료구조, 함수 등을 제공하는 라이브러리임

`알고리즘`, `컨테이너`, `이터레이터`, `펑터` 이렇게 4가지를 제공해줌

`vector`라는 자료구조를 쓴다던가 `sort()` 함수를 쓸 수 있게 되는 게 다 `STL` 덕분임

#### 알고리즘이 뭔데

> 정렬, 탐색 등에 관한 함수로 이루어져 있음. sort()가 대표적임.

#### 컨테이너는 뭔데

> c++에서 제공하는 자료구조를 의미한다.

`시퀀스 컨테이너`

- 데이터를 단순히 저장해 놓는 자료구조다.
- `array`, `vector`, `deque`, `forward_list`, `list`가 있음.

`연관 컨테이너`

- 자료가 저장됨에 따라 자동정렬되는 자료구조다. 중복키가 가능한 것은 이름에 `multi`가 붙음.
- `set`, `map`, `multiset`, `multimap`이 있음.

`정렬되지 않은 연관 컨테이너`

- 자료가 저장됨에 따라 자동정렬이 되지 않는 자료구조다.
- `unordered_set`, `unordered_map`, `unordered_multiset`, `unordered_multimap`이 있음.

`컨테이너 어댑터`

- 시퀀스 컨테이너를 이용해 만든 자료구조다.
- `stack`, `queue`는 `deque`로 만들어졌고, `priority_queue`는 `vector`로 만들었다.

#### 이터레이터는 뭔데

> 추후 공부 후, 정리할 거

#### 펑터는 뭔데

> 함수 호출 연산자를 오버로드하는 클래스 인스턴스를 말한다. 여기서는 활용하지 않음.

<hr />

### 입력

> cin, scanf가 있음.

#### cin

> 개행문자까지 입력을 받음

#### scanf

> 형식을 지정해서 입력을 받음

int = d
char = c
string = s
double = lf
long long = ld

#### getline

> 개행문자까지 전부 한꺼번에 받기 가능함

cin으로 T개의 getline을 받을지 설정하는 경우도 있음.
그때는 특정 문자열을 기반으로 `버퍼플래시`를 하고 받아야 한다.

cin으로 입력을 받을 때, 개행문자 직전까지 입력을 받게 되고, 이 때문에 중간에 위치한 버퍼에 `\n`이 남아있게 된다.
이를 없애기 위해 `getline(cin, bufferflush)`를 해줘야 한다.

### 출력

> cout과 printf가 있음.

#### printf

string str을 출력할 떄는 `c_str()`함수를 걸어 출력해야 한다.
그 이유는 printf 기반으로 문자열을 출력하려면 string을 `문자열에 대한 포인터 (char *) 타입`으로 바꿔줘야 하기 때문이다.
그래서 보통 `cout`을 사용하는 것이 좋다.

<hr />

### 타입

> void, char, string, bool, int, long long, double, unsigned long long

#### void : 리턴하는 값이 없다.

#### char : 문자

> 작은 따옴표로 선언해야 하고, 1바이트 크기를 가진다.

#### string: 문자열

> char[]로 선언하거나 그냥 string으로 선언해 여러개의 문자모음이자 문자배열인 문자열을 선언할 수 있다.

`+=`

> 메서드는 아니고, 문자열에 문자열을 더할 때 사용한다.

    `push_back()`라는 메서드가 있지만, 이는 문자하나씩밖에 더하지 못하기에 보통 이걸 사용한다.

`begin()`

> 문자열의 첫 번째 요소를 가리키는 이터레이터를 반환한다. 이를 기반으로 \*를 통해 해당 위치 값을 가져올 수 있다.

`end()`

> 문자열 마지막 요소 그 다음을 가리키는 이터레이터를 반환한다.

`size()`

> 문자열 사이즈를 반환한다. O(1).

`insert(위치, 문자열)`

> 특정 위치에 문자열을 삽입한다. O(n).

`erase(위치, 크기)`

> 특정 위치에 크기만큼 문자열을 지운다. O(n)

`pop_back()`

> 문자열 끝을 지운다. O(1)

`find(문자열)`

> 특정 문자열을 찾아 위치를 반환한다. 못 찾게 된다면, string::npos를 반환하고 O(n).

    string::npos는 size_t 타입의 최댓값을 의미한다.

`substr(위치, 크기)`

> 특정 위치에서 크기만큼의 문자열을 추출한다. O(n).

`아스키코드와 문자열`

> 아스키 코드를 통해 숫자로 된 문자를 반환한다.

`reverse()`

> string은 해당 메서드를 지원하지 않는다. 거꾸로 뒤집고 싶다면, STL에서 지원하는 함수 reverse()를 써야 한다.

    void reverse (BidirectionalIterator first, BidirectionalIterator last);
    아무것도 반환하지 않는다. 원본 문자열 자체를 바꿔버린다.

`split()`

> 이 메서드는 존재하지 않기 때문에 직접 구현해야 한다. O(n).

```c++
#include <bits/stdc++.h>
using namespace std;

vector<string> split(string input, string delimiter) {
    vector<string> ret;
    long long pos = 0;
    string token = "";
    while((pos = input.find(delimiter)) != string::npos) {
        token = input.substr(0, pos);
        ret.push_back(token);
        input.erase(0, pos + delimiter.length());
    }
    ret.push_back(input);
    return ret;
}

int main() {
    string s = "안녕하세요. 최준혁입니다.", d = " ";
    vector<string> a = split(s, d);
    for(string b : a) cout << b << "\n";
}
```

`atoi(s.c_str())`

> 문자열을 int로 바꿔야 할 상황이 있을 수 있음. 해당 글자가 문자열인지 숫자인지 확인할 경우에 사용한다.

    문자열이 문자라면 0을 반환한다.

<hr />

### 숫자

#### 오버플로

> 타입의 허용범위를 넘어갈 때 발생하는 에러다.

    최대 범위에 1을 더하면 최솟값으로 돌아감

#### 언더플로

> 오버플로와 반대되는 개념이다.

    이또한 최소 범위에 1을 빼면 최댓값으로 돌아감

<hr />

### pair와 tuple

    pair는 first와 second라는 멤버변수를 가지는 클래스다. (두 가지가 최대)

    tuple은 세 가지 이상의 값을 담을 떄 사용함.

```c++
tuple<int, int, int> tl;

tl = make_tuple(1,2,3);
tie(a,b,c) = tl;
```

<hr />

### auto 타입

> 타입 추론해 결정되는 타입이다.

```c++
// 두 개 다 동일함
pair<int, int> it;
auto it;
```

<hr />

### 메모리와 포인터

#### 메모리란

> 메모리 셀의 연속과 같으며, 각 셀의 크기는 1바이트이며 고유한 주소가 있다.

c++에서는 변수의 메모리 주소를 출력해볼 수 있다.

```c++
int i;

int main() {
    cout << &i << "\n";
    i = 10
    cout << &i << "\n";
    return 0;
}
// 0x100bbc000
// 0x100bbc000
```

주소는 예약한 메모리 영역에 해당 값을 저장하게 된다.
그래서 어떤 값을 넣든 주소는 변하지 않는다.

#### 포인터란

> 메모리 관리는 언어마다 조금은 다르게 관리된다. 자바, 파이썬, 자바스크립트에서는 개발자가 직접 변수에 메모리를 할당하거나 해제할 수 없고, 가비지컬렉터를 통해 이를 수행한다.

변수의 메모리 주소를 담는 타입이 바로 `포인터`다.
메모리 동적할당, 데이터를 복사하지 않고 함수 매개변수로 사용, 클래스 및 구조체를 연결할 때 사용된다.

#### 역참조 연산자

> & 연산자로는 주소를 불러올 수 있고, \* 연산자로는 해당 주소값에 담긴 값을 불러올 수 있다.

```c++
int main() {
    string a = "abcde";
    string * b = &a;
    cout << b << "\n";
    cout << *b << "\n";

    return 0;
}
// 0x100bbc000
// abcde
```

#### Array to Pointer Decay

배열이 포인터로 부식되는 현상을 말한다.
배열의 이름을 주소값으로 사용할 수 있다는 걸 의미한다.
이를 통해 배열의 이름은 배열의 첫 번째 주소로 사용이 가능하다.

```c++
int a[3] = {1,2,3};

int main() {
    int * c = a;
    cout << c << "\n";
    cout << &a[0] << "\n";
    return 0;
}
// 0x100bbc000
// 0x100bbc000
```

#### 프로세스 메모리 구조

> 스택, 힙, 데이터 영역, 코드영역으로 나뉜다.

1. 스택

   지역 변수, 매개 변수, 함수가 저장되고 컴파일 시에 크기가 결정된다.
   그러나 함수가 함수를 호출하는 등에 따라 런타임시에도 크기가 변경된다.
   동적이다.

2. 힙

   동적 할당할 때 사용되며, 런타임 시 크기가 결정된다.
   동적이다.

3. 데이터 영역

   BSS 영역과 DATA 영역으로 나뉜다.
   정적 할당에 관한 부분을 담당한다.
   정적이다.

4. 코드 영역

   소스코드가 들어간다.
   정적이다.

#### 정적할당

> 컴파일 단계에서 메모리를 할당한다. BSS segement, Data segment, code / text segment 세 가지로 나뉘어서 저장된다.

`BSS segment`

    전역 변수, static, const로 선언된 변수 중 0으로 초기화 또는 초기화가 어떤 값으로도 되어 있지 않은 변수들이 이 메모리 영역에 할당된다.

`Data segment`

    전역 변수, static, const로 선언된 변수 중 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당된다.

`code / text segment`

    프로그램의 코드가 들어간다.

#### 동적할당

> 런타임 단계에서 메모리를 할당받는 것이며, Stack과 Heap으로 나뉜다.

`Stack`

    지역 변수, 매개 변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역이다.
    함수가 호출될 때마다 해당 환경 등 특정 정보가 여기에 계속 저장된다.
    재귀함수가 불렸다면, 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않는다.
    즉, 재귀함수 내의 지역변수로 선언하게 되면, 해당 변수는 독립적으로 작용하며 다른 함수에 있는 변수에 영향을 미치지 않는다.

`Heap`

    동적으로 할당되는 변수들을 담는다.
    `malloc()`, `free()` 함수를 통해 관리가 가능하다.
    동적으로 관리되는 자료구조는 여기를 사용한다.
    `vector`가 여기에 속한다.

### 이터레이터

> 컴테이너에 저장된 요소의 주소를 가리키는 개체를 말한다. 포인터를 일반화한 것이다. 일반화된 이터레이터로 다양한 컨테이너를 쉽게 순회할 수 있다.

이는 주소값을 바로 반환하지 못하고, `&`, `*`를 통해 한단계 거쳐서 가리키는 해당 요소의 주소값을 반환할 수 있다.

#### begin()

> 컨테이너의 시작 위치를 반환한다.

#### end()

> 컨테이너의 끝 다음의 위치를 반환한다.

#### advance(iterator, cnt)

> 해당 iterator를 cnt까지 증가시킨다.

#### 이터레이터와 포인터 차이

`이터레이터`

    어떤 컨테이너의 범위 안에서 일부 요소를 가리키며 해당 요소를 순회할 수 있는 개체다.
    이는 컨테이너의 개체를 참조하는 것이기에 이 자체를 제거할 순 없다.

`포인터`

    변수의 메모리 주소를 저장하는 개체이며, 포인터는 delete를 통해 포인터를 제거할 수 있다.

#### 이터레이터 = 일반화된 포인터?

일반화는 여러 사례들의 공통되는 속성들을 일반적인 개념으로 추상화의 한 형태다.

이터레이터는 컨테이너의 구조나 컨테이너 안에 들어가 있는 요소의 타입과는 상관없이 컨테이너에 저장된 데이터를 순회하는 과정을 담당한다.
즉, 각각의 다른 요소들을 쉽게 탐색할 수 있게 "일반화"한 장치다.

<hr />

### 함수
